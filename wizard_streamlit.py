import streamlit as st
import pandas as pd
import numpy as np
import pyreadstat
import io
from datetime import datetime
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# Configuraci√≥n de estilo
plt.style.use('default')
sns.set_palette("husl")

# =====================
# Funci√≥n de detecci√≥n de tipos de columna
# =====================
def detectar_tipos_columnas(df: pd.DataFrame, umbral_cardinalidad=20, umbral_texto_largo=50):
    """
    Detecta el tipo de dato de cada columna en un DataFrame de pandas.
    """
    resumen = []
    for col in df.columns:
        serie = df[col]
        tipo = None
        detalles = ""
        if serie.isnull().all():
            tipo = "vac√≠a"
            detalles = "Todos los valores son NaN"
        elif pd.api.types.is_bool_dtype(serie):
            tipo = "booleano"
        elif pd.api.types.is_datetime64_any_dtype(serie):
            tipo = "fecha/tiempo"
        elif pd.api.types.is_numeric_dtype(serie):
            tipo = "num√©rico"
        elif pd.api.types.is_object_dtype(serie) or pd.api.types.is_categorical_dtype(serie):
            n_unicos = serie.nunique(dropna=True)
            muestra = serie.dropna().astype(str).sample(min(10, len(serie.dropna())), random_state=1) if len(serie.dropna()) > 0 else []
            longitudes = muestra.map(len) if len(muestra) > 0 else []
            if n_unicos <= umbral_cardinalidad:
                tipo = "categ√≥rico"
                detalles = f"{n_unicos} valores √∫nicos"
            elif len(longitudes) > 0 and np.mean(longitudes) > umbral_texto_largo:
                tipo = "texto libre"
                detalles = f"Longitud promedio texto: {np.mean(longitudes):.1f}"
            elif serie.apply(lambda x: isinstance(x, (int, float, np.number))).any():
                tipo = "mixto"
                detalles = "Contiene mezcla de tipos (num√©rico y texto)"
            else:
                tipo = "texto"
        else:
            tipo = "requiere revisi√≥n"
            detalles = f"Tipo detectado: {serie.dtype}"
        resumen.append({
            "columna": col,
            "tipo_detectado": tipo,
            "detalles": detalles
        })
    return pd.DataFrame(resumen)

# =====================
# Funci√≥n para sugerir visualizaciones (simplificada)
# =====================
def sugerir_visualizaciones(tipo, df=None, col=None):
    """
    Sugiere visualizaciones seg√∫n el tipo de variable.
    Estructura preparada para futuras visualizaciones bivariadas.
    """
    sugerencias = []
    
    # Visualizaciones univariadas b√°sicas
    if tipo == "num√©rico":
        sugerencias = ["Histograma", "Boxplot", "Estad√≠sticas descriptivas"]
    elif tipo == "categ√≥rico":
        sugerencias = ["Gr√°fico de barras", "Gr√°fico de torta", "Tabla de frecuencias"]
    elif tipo == "booleano":
        sugerencias = ["Gr√°fico de barras", "Tabla de frecuencias"]
    elif tipo == "fecha/tiempo":
        sugerencias = ["Serie temporal", "Distribuci√≥n temporal"]
    elif tipo == "texto libre":
        sugerencias = ["Tabla de frecuencias", "Longitud de texto"]
    else:
        sugerencias = ["Tabla de frecuencias"]
    
    # Nota: Aqu√≠ se pueden agregar sugerencias bivariadas en el futuro
    # Por ejemplo: "Dispersi√≥n", "Boxplot agrupado", "Correlaci√≥n", etc.
    
    return sugerencias

# =====================
# Funci√≥n para cargar archivos de distintos formatos
# =====================
def cargar_archivo(uploaded_file):
    """Carga archivos .csv, .xlsx, .sav, .dta en un DataFrame."""
    nombre = uploaded_file.name.lower()
    if nombre.endswith('.csv'):
        return pd.read_csv(uploaded_file)
    elif nombre.endswith('.xlsx') or nombre.endswith('.xls'):
        return pd.read_excel(uploaded_file)
    elif nombre.endswith('.sav'):
        df, meta = pyreadstat.read_sav(uploaded_file)
        return df
    elif nombre.endswith('.dta'):
        df, meta = pyreadstat.read_dta(uploaded_file)
        return df
    else:
        raise ValueError("Formato de archivo no soportado")

# =====================
# Funciones de visualizaci√≥n (estructura preparada para expansi√≥n)
# =====================
def crear_visualizacion(df, col, tipo_vis, tipo_col):
    """
    Crea visualizaciones usando Plotly para mejor interactividad.
    Estructura preparada para futuras visualizaciones bivariadas.
    """
    
    # Limpiar datos
    datos_limpios = df[col].dropna()
    
    if tipo_vis == "Histograma" and tipo_col == "num√©rico":
        fig = px.histogram(
            df, x=col, 
            title=f"Distribuci√≥n de {col}",
            nbins=30,
            marginal="box"
        )
        fig.update_layout(
            xaxis_title=col,
            yaxis_title="Frecuencia",
            showlegend=False
        )
        return fig
    
    elif tipo_vis == "Boxplot" and tipo_col == "num√©rico":
        fig = px.box(
            df, y=col,
            title=f"Boxplot de {col}"
        )
        fig.update_layout(
            yaxis_title=col,
            showlegend=False
        )
        return fig
    
    elif tipo_vis == "Gr√°fico de barras" and tipo_col in ["categ√≥rico", "booleano"]:
        # Limitar a top 20 categor√≠as para mejor visualizaci√≥n
        frecuencias = df[col].value_counts().head(20)
        fig = px.bar(
            x=frecuencias.index, 
            y=frecuencias.values,
            title=f"Frecuencia de {col}",
            labels={'x': col, 'y': 'Frecuencia'}
        )
        fig.update_layout(showlegend=False)
        return fig
    
    elif tipo_vis == "Gr√°fico de torta" and tipo_col in ["categ√≥rico", "booleano"]:
        # Limitar a top 10 categor√≠as para mejor visualizaci√≥n
        frecuencias = df[col].value_counts().head(10)
        fig = px.pie(
            values=frecuencias.values,
            names=frecuencias.index,
            title=f"Distribuci√≥n de {col}"
        )
        return fig
    
    elif tipo_vis == "Serie temporal" and tipo_col == "fecha/tiempo":
        # Agrupar por fecha y contar
        df_temp = df.copy()
        df_temp[col] = pd.to_datetime(df_temp[col])
        serie_temporal = df_temp[col].value_counts().sort_index()
        
        fig = px.line(
            x=serie_temporal.index,
            y=serie_temporal.values,
            title=f"Serie temporal de {col}",
            labels={'x': 'Fecha', 'y': 'Frecuencia'}
        )
        return fig
    
    elif tipo_vis == "Estad√≠sticas descriptivas" and tipo_col == "num√©rico":
        # Crear tabla de estad√≠sticas
        stats = df[col].describe()
        fig = go.Figure(data=[go.Table(
            header=dict(values=['Estad√≠stica', 'Valor']),
            cells=dict(values=[
                ['Conteo', 'Media', 'Desv. Est.', 'M√≠nimo', '25%', 'Mediana', '75%', 'M√°ximo'],
                [f"{stats['count']:.0f}", f"{stats['mean']:.2f}", f"{stats['std']:.2f}", 
                 f"{stats['min']:.2f}", f"{stats['25%']:.2f}", f"{stats['50%']:.2f}", 
                 f"{stats['75%']:.2f}", f"{stats['max']:.2f}"]
            ])
        )])
        fig.update_layout(title=f"Estad√≠sticas descriptivas de {col}")
        return fig
    
    elif tipo_vis == "Tabla de frecuencias":
        frecuencias = df[col].value_counts()
        fig = go.Figure(data=[go.Table(
            header=dict(values=[col, 'Frecuencia', 'Porcentaje']),
            cells=dict(values=[
                frecuencias.index.astype(str),
                frecuencias.values,
                [f"{(freq/len(df)*100):.1f}%" for freq in frecuencias.values]
            ])
        )])
        fig.update_layout(title=f"Tabla de frecuencias de {col}")
        return fig
    
    elif tipo_vis == "Longitud de texto" and tipo_col == "texto libre":
        longitudes = df[col].astype(str).str.len()
        fig = px.histogram(
            x=longitudes,
            title=f"Distribuci√≥n de longitudes de texto en {col}",
            nbins=30
        )
        fig.update_layout(
            xaxis_title="Longitud del texto",
            yaxis_title="Frecuencia"
        )
        return fig
    
    else:
        # Fallback: tabla de frecuencias
        frecuencias = df[col].value_counts().head(20)
        fig = go.Figure(data=[go.Table(
            header=dict(values=[col, 'Frecuencia']),
            cells=dict(values=[
                frecuencias.index.astype(str),
                frecuencias.values
            ])
        )])
        fig.update_layout(title=f"Frecuencias de {col}")
        return fig

# =====================
# Wizard de visualizaci√≥n de datos
# =====================
st.set_page_config(
    page_title="Asistente de Visualizaci√≥n de Datos", 
    layout="wide",
    initial_sidebar_state="expanded"
)

st.title("ü§ñ Asistente de Visualizaci√≥n de Datos")
st.markdown("**Gu√≠a paso a paso para crear visualizaciones efectivas de tus datos**")

# Inicializaci√≥n del estado de la sesi√≥n
if 'paso' not in st.session_state:
    st.session_state.paso = 1
if 'df' not in st.session_state:
    st.session_state.df = None
if 'resumen' not in st.session_state:
    st.session_state.resumen = None
if 'columna_seleccionada' not in st.session_state:
    st.session_state.columna_seleccionada = None
if 'tipo_columna' not in st.session_state:
    st.session_state.tipo_columna = None
if 'visualizacion' not in st.session_state:
    st.session_state.visualizacion = None

# Sidebar: navegaci√≥n y ayuda
with st.sidebar:
    st.title("üó∫Ô∏è Navegaci√≥n")
    st.progress(st.session_state.paso / 7)
    
    st.markdown("""
    **Pasos a seguir:**
    1. üìÅ Cargar archivo
    2. üìä Resumen de datos
    3. üîç Detecci√≥n de tipos
    4. üí° Sugerencias
    5. üé® Selecci√≥n de gr√°fico
    6. üìà Visualizaci√≥n
    7. üíæ Exportar resultados
    """)
    
    st.markdown("---")
    st.markdown("**üí° Tip:** En el futuro podr√°s crear visualizaciones que relacionen dos variables.")
    
    if st.button("üîÑ Reiniciar Asistente"):
        for key in list(st.session_state.keys()):
            del st.session_state[key]
        st.rerun()

# Paso 1: Cargar archivo
def paso_1():
    st.header("üìÅ Paso 1: Cargar archivo de datos")
    
    col1, col2 = st.columns([2, 1])
    
    with col1:
        archivo = st.file_uploader(
            "Carga tu archivo de datos", 
            type=["csv", "xlsx", "xls", "sav", "dta"],
            help="Formatos soportados: CSV, Excel, SPSS (.sav), Stata (.dta)"
        )
        
        if archivo is not None:
            try:
                with st.spinner("Cargando archivo..."):
                    df = cargar_archivo(archivo)
                    st.session_state.df = df
                
                st.success(f"‚úÖ Archivo cargado correctamente")
                st.info(f"üìä **Datos:** {df.shape[0]:,} filas √ó {df.shape[1]} columnas")
                
                if st.button("‚û°Ô∏è Continuar al siguiente paso", type="primary"):
                    st.session_state.paso = 2
                    st.rerun()
                    
            except Exception as e:
                st.error(f"‚ùå Error al cargar archivo: {str(e)}")
                st.info("üí° Aseg√∫rate de que el archivo no est√© corrupto y sea del formato correcto.")
        else:
            st.info("üì§ Por favor, sube un archivo de datos para comenzar.")
    
    with col2:
        st.markdown("""
        **üìã Formatos soportados:**
        - **CSV** (.csv)
        - **Excel** (.xlsx, .xls)
        - **SPSS** (.sav)
        - **Stata** (.dta)
        
        **üí° Consejo:** Para mejores resultados, aseg√∫rate de que tu archivo tenga encabezados en la primera fila.
        """)

# Paso 2: Resumen autom√°tico
def paso_2():
    st.header("üìä Paso 2: Resumen autom√°tico de los datos")
    
    df = st.session_state.df
    
    col1, col2 = st.columns([1, 1])
    
    with col1:
        st.subheader("üìã Informaci√≥n general")
        st.metric("Filas", f"{df.shape[0]:,}")
        st.metric("Columnas", df.shape[1])
        st.metric("Memoria utilizada", f"{df.memory_usage(deep=True).sum() / 1024**2:.1f} MB")
        
        st.subheader("üîç Primeras filas")
        st.dataframe(df.head(), use_container_width=True)
    
    with col2:
        st.subheader("üìà Tipos de datos")
        tipos_df = pd.DataFrame(df.dtypes, columns=["Tipo"])
        tipos_df["No nulos"] = df.count()
        tipos_df["% Completitud"] = (df.count() / len(df) * 100).round(1)
        st.dataframe(tipos_df, use_container_width=True)
        
        st.subheader("‚ö†Ô∏è Valores faltantes")
        missing_df = pd.DataFrame({
            "Columna": df.columns,
            "Valores faltantes": df.isnull().sum(),
            "% Faltantes": (df.isnull().sum() / len(df) * 100).round(1)
        })
        st.dataframe(missing_df[missing_df["Valores faltantes"] > 0], use_container_width=True)
    
    col1, col2, col3 = st.columns([1, 1, 1])
    with col2:
        if st.button("‚û°Ô∏è Continuar", type="primary"):
            st.session_state.paso = 3
            st.rerun()
    with col1:
        if st.button("‚¨ÖÔ∏è Volver"):
            st.session_state.paso = 1
            st.rerun()

# Paso 3: Detecci√≥n autom√°tica de tipo de variable
def paso_3():
    st.header("üîç Paso 3: Detecci√≥n autom√°tica de tipos de variables")
    
    df = st.session_state.df
    
    with st.spinner("Analizando tipos de variables..."):
        resumen = detectar_tipos_columnas(df)
        st.session_state.resumen = resumen
    
    st.subheader("üìã Resultados del an√°lisis")
    st.dataframe(resumen, use_container_width=True)
    
    # Resumen visual de tipos
    st.subheader("üìä Distribuci√≥n de tipos de variables")
    tipo_counts = resumen["tipo_detectado"].value_counts()
    fig = px.pie(
        values=tipo_counts.values,
        names=tipo_counts.index,
        title="Distribuci√≥n de tipos de variables detectados"
    )
    st.plotly_chart(fig, use_container_width=True)
    
    st.info("üí° Los tipos detectados autom√°ticamente te ayudar√°n a elegir las mejores visualizaciones.")
    
    col1, col2, col3 = st.columns([1, 1, 1])
    with col2:
        if st.button("‚û°Ô∏è Continuar", type="primary"):
            st.session_state.paso = 4
            st.rerun()
    with col1:
        if st.button("‚¨ÖÔ∏è Volver"):
            st.session_state.paso = 2
            st.rerun()

# Paso 4: Sugerencia de visualizaciones
def paso_4():
    st.header("üí° Paso 4: Sugerencias de visualizaci√≥n")
    
    df = st.session_state.df
    resumen = st.session_state.resumen
    
    col = st.selectbox(
        "üéØ Selecciona la variable que quieres visualizar:",
        resumen["columna"],
        help="Elige la variable que te interesa analizar"
    )
    
    tipo = resumen[resumen["columna"] == col]["tipo_detectado"].values[0]
    st.session_state.columna_seleccionada = col
    st.session_state.tipo_columna = tipo
    
    col1, col2 = st.columns([1, 1])
    
    with col1:
        st.subheader(f"üìä Variable: {col}")
        st.info(f"**Tipo detectado:** {tipo}")
        
        # Mostrar estad√≠sticas r√°pidas
        if tipo == "num√©rico":
            stats = df[col].describe()
            st.metric("Media", f"{stats['mean']:.2f}")
            st.metric("Mediana", f"{stats['50%']:.2f}")
            st.metric("Desv. Est.", f"{stats['std']:.2f}")
        elif tipo in ["categ√≥rico", "booleano"]:
            st.metric("Valores √∫nicos", df[col].nunique())
            st.metric("Valor m√°s frecuente", df[col].mode().iloc[0] if len(df[col].mode()) > 0 else "N/A")
    
    with col2:
        st.subheader("üé® Visualizaciones sugeridas")
        sugerencias = sugerir_visualizaciones(tipo, df, col)
        
        for i, sugerencia in enumerate(sugerencias, 1):
            st.write(f"{i}. **{sugerencia}**")
        
        st.info("üí° Estas sugerencias est√°n basadas en el tipo de variable detectado.")
    
    col1, col2, col3 = st.columns([1, 1, 1])
    with col2:
        if st.button("‚û°Ô∏è Continuar", type="primary"):
            st.session_state.paso = 5
            st.rerun()
    with col1:
        if st.button("‚¨ÖÔ∏è Volver"):
            st.session_state.paso = 3
            st.rerun()

# Paso 5: Selecci√≥n de visualizaci√≥n
def paso_5():
    st.header("üé® Paso 5: Selecci√≥n de visualizaci√≥n")
    
    df = st.session_state.df
    col = st.session_state.columna_seleccionada
    tipo = st.session_state.tipo_columna
    
    st.subheader(f"üìä Variable seleccionada: {col}")
    st.info(f"**Tipo:** {tipo}")
    
    sugerencias = sugerir_visualizaciones(tipo, df, col)
    
    vis = st.selectbox(
        "üé® Elige el tipo de visualizaci√≥n:",
        sugerencias,
        help="Selecciona la visualizaci√≥n que mejor represente tus datos"
    )
    
    st.session_state.visualizacion = vis
    
    # Mostrar descripci√≥n de la visualizaci√≥n
    descripciones = {
        "Histograma": "Muestra la distribuci√≥n de frecuencias de una variable num√©rica",
        "Boxplot": "Visualiza la distribuci√≥n y detecta valores at√≠picos",
        "Gr√°fico de barras": "Compara frecuencias entre categor√≠as",
        "Gr√°fico de torta": "Muestra proporciones de una variable categ√≥rica",
        "Serie temporal": "Visualiza cambios a lo largo del tiempo",
        "Estad√≠sticas descriptivas": "Tabla con medidas estad√≠sticas resumidas",
        "Tabla de frecuencias": "Lista detallada de frecuencias y porcentajes",
        "Longitud de texto": "Distribuci√≥n de longitudes de texto"
    }
    
    st.info(f"**Descripci√≥n:** {descripciones.get(vis, 'Visualizaci√≥n de datos')}")
    
    col1, col2, col3 = st.columns([1, 1, 1])
    with col2:
        if st.button("‚û°Ô∏è Crear visualizaci√≥n", type="primary"):
            st.session_state.paso = 6
            st.rerun()
    with col1:
        if st.button("‚¨ÖÔ∏è Volver"):
            st.session_state.paso = 4
            st.rerun()

# Paso 6: Mostrar gr√°fico o indicador
def paso_6():
    st.header("üìà Paso 6: Visualizaci√≥n de los datos")
    
    df = st.session_state.df
    col = st.session_state.columna_seleccionada
    vis = st.session_state.visualizacion
    tipo = st.session_state.tipo_columna
    
    st.subheader(f"üìä Resultado: {vis} de '{col}'")
    
    try:
        fig = crear_visualizacion(df, col, vis, tipo)
        st.plotly_chart(fig, use_container_width=True)
        
        # Informaci√≥n adicional
        with st.expander("üìã Informaci√≥n adicional"):
            st.write(f"**Variable:** {col}")
            st.write(f"**Tipo:** {tipo}")
            st.write(f"**Visualizaci√≥n:** {vis}")
            st.write(f"**Total de registros:** {len(df):,}")
            st.write(f"**Registros v√°lidos:** {len(df[col].dropna()):,}")
            st.write(f"**Registros faltantes:** {df[col].isnull().sum():,}")
            
            if tipo == "num√©rico":
                stats = df[col].describe()
                st.write("**Estad√≠sticas descriptivas:**")
                st.dataframe(pd.DataFrame(stats).T)
    
    except Exception as e:
        st.error(f"‚ùå Error al crear la visualizaci√≥n: {str(e)}")
        st.info("üí° Intenta con otra visualizaci√≥n o revisa los datos.")
    
    col1, col2, col3 = st.columns([1, 1, 1])
    with col2:
        if st.button("‚û°Ô∏è Continuar", type="primary"):
            st.session_state.paso = 7
            st.rerun()
    with col1:
        if st.button("‚¨ÖÔ∏è Volver"):
            st.session_state.paso = 5
            st.rerun()

# Paso 7: Exportar resultados
def paso_7():
    st.header("üíæ Paso 7: Exportar resultados")
    
    df = st.session_state.df
    resumen = st.session_state.resumen
    
    st.success("üéâ ¬°Has completado el asistente de visualizaci√≥n!")
    
    col1, col2 = st.columns([1, 1])
    
    with col1:
        st.subheader("üìÅ Descargar datos")
        st.download_button(
            "üìä Datos originales (CSV)",
            df.to_csv(index=False),
            file_name="datos_originales.csv",
            mime="text/csv"
        )
        
        st.download_button(
            "üìã Resumen de tipos (CSV)",
            resumen.to_csv(index=False),
            file_name="resumen_tipos_variables.csv",
            mime="text/csv"
        )
    
    with col2:
        st.subheader("üìà Pr√≥ximas mejoras")
        st.markdown("""
        **üöÄ En futuras versiones podr√°s:**
        - üìä Crear visualizaciones con dos variables
        - üé® Personalizar colores y estilos
        - üì± Exportar gr√°ficos como im√°genes
        - üîÑ Guardar y cargar configuraciones
        - üìà An√°lisis estad√≠sticos avanzados
        """)
    
    st.markdown("---")
    st.info("üí° **Consejo:** Para exportar la visualizaci√≥n como imagen, usa el bot√≥n de descarga de Plotly en la esquina superior derecha del gr√°fico.")
    
    col1, col2, col3 = st.columns([1, 1, 1])
    with col2:
        if st.button("üîÑ Crear nueva visualizaci√≥n", type="primary"):
            st.session_state.paso = 4
            st.rerun()
    with col1:
        if st.button("‚¨ÖÔ∏è Volver"):
            st.session_state.paso = 6
            st.rerun()

# =====================
# Controlador de pasos
# =====================
if st.session_state.paso == 1:
    paso_1()
elif st.session_state.paso == 2:
    paso_2()
elif st.session_state.paso == 3:
    paso_3()
elif st.session_state.paso == 4:
    paso_4()
elif st.session_state.paso == 5:
    paso_5()
elif st.session_state.paso == 6:
    paso_6()
elif st.session_state.paso == 7:
    paso_7() 